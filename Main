#include <iostream>
#include <vector>
#include <chrono>
#include <cmath>

// Функция для проверки, является ли число простым (метод перебора)
bool isPrime(int n) {
    if (n <= 1) return false;
    for (int i = 2; i <= sqrt(n); ++i) {
        if (n % i == 0) return false;
    }
    return true;
}

// Функция для проверки, является ли число простым (алгоритм Ферма)
bool isFermatPrime(int n) {
    if (n <= 1) return false;
    if (n == 2) return true;
    for (int a = 2; a < n; ++a) {
        if (static_cast<int>(std::pow(a, n - 1)) % n != 1) {
            return false;
        }
    }
    return true;
}

// Функция для поиска простых чисел методом перебора
void findPrimesByTrialDivision(int start, int end) {
    auto start_time = std::chrono::steady_clock::now();
    std::vector<int> primes;
    for (int i = start; i <= end; ++i) {
        if (isPrime(i)) {
            primes.push_back(i);
        }
    }
    auto end_time = std::chrono::steady_clock::now();
    std::cout << "Trial Division: Found " << primes.size() << " prime numbers in "
              << std::chrono::duration_cast<std::chrono::milliseconds>(end_time - start_time).count()
              << " milliseconds" << std::endl;
}

// Функция для поиска простых чисел методом Решета Эратосфена
void findPrimesBySieveOfEratosthenes(int start, int end) {
    auto start_time = std::chrono::steady_clock::now();
    std::vector<bool> isPrime(end + 1, true);
    isPrime[0] = isPrime[1] = false;
    for (int p = 2; p * p <= end; ++p) {
        if (isPrime[p]) {
            for (int i = p * p; i <= end; i += p) {
                isPrime[i] = false;
            }
        }
    }
    std::vector<int> primes;
    for (int i = start; i <= end; ++i) {
        if (isPrime[i]) {
            primes.push_back(i);
        }
    }
    auto end_time = std::chrono::steady_clock::now();
    std::cout << "Sieve of Eratosthenes: Found " << primes.size() << " prime numbers in "
              << std::chrono::duration_cast<std::chrono::milliseconds>(end_time - start_time).count()
              << " milliseconds" << std::endl;
}

// Функция для поиска простых чисел методом Ферма
void findPrimesByFermatMethod(int start, int end) {
    auto start_time = std::chrono::steady_clock::now();

    std::vector<int> primes;
    for (int i = start; i <= end; ++i) {
        bool isPrime = true;
        if (i <= 1) {
            isPrime = false;
        } else {
            for (int j = 2; j <= sqrt(i); ++j) {
                if (i % j == 0) {
                    isPrime = false;
                    break;
                }
            }
        }
        if (isPrime) {
            primes.push_back(i);
        }
    }
    auto end_time = std::chrono::steady_clock::now();
    std::cout << "Fermat's Algorithm: Found " << primes.size() << " prime numbers in "
              << std::chrono::duration_cast<std::chrono::milliseconds>(end_time - start_time).count()
              << " milliseconds" << std::endl;
}

int main(int argc, char *argv[]) {
    if (argc < 2 || argc > 3) {
        std::cerr << "Usage: " << argv[0] << " <end_number> [start_number=1]" << std::endl;
        return 1;
    }

    int start = 1; // Начало диапазона по умолчанию
    int end = std::stoi(argv[1]); // Преобразование первого аргумента в конец диапазона

    if (argc == 3) {
        start = std::stoi(argv[2]); // Преобразование второго аргумента в начало диапазона
    }

    if (start > end) {
        int temp = start;
        start = end;
        end = temp;
    }

    if (start < 1 || end < 1) {
        std::cerr << "Error: Numbers must be positive integers." << std::endl;
        return 1;
    }

    std::cout << "Start from: " << start << std::endl; // Добавленная строка "Start from"
    std::cout << "Ends with: " << end << std::endl; // Добавленная строка "Ends with"

    findPrimesByTrialDivision(start, end); // Поиск простых чисел методом перебора
    findPrimesBySieveOfEratosthenes(start, end); // Поиск простых чисел методом Решета Эратосфена
    findPrimesByFermatMethod(start, end); // Поиск простых чисел методом Ферма

    return 0;
}
