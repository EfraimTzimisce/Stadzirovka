#include <iostream>
#include <vector>
#include <chrono>
#include <cmath>

/*

Команда для сборки g++ -o Stadzirovka Stadzirovka.cpp
Команда для вызова программы ./Stadzirovka <подставить один или два аргумента, например ./Stadzirovka 50 100 или ./Stadzirovka 50>

Результаты тестов

Start from: 1
Ends with: 1000
Trial Division: Found 168 prime numbers in 0 milliseconds
Sieve of Eratosthenes: Found 168 prime numbers in 0 milliseconds
Fermat's Algorithm: Found 168 prime numbers in 0 milliseconds

Start from: 70
Ends with: 10000000
Trial Division: Found 664560 prime numbers in 8930 milliseconds
Sieve of Eratosthenes: Found 664560 prime numbers in 486 milliseconds
Fermat's Algorithm: Found 664560 prime numbers in 8916 milliseconds

Start from: 1
Ends with: 622337203
Trial Division: Found 32428773 prime numbers in 3302759 milliseconds
Sieve of Eratosthenes: Found 32428773 prime numbers in 38897 milliseconds
Fermat's Algorithm: Found 32428773 prime numbers in 3350990 milliseconds

Программа выдает количество найденных простых чисел, времяв затраченное на поиск, а также начало и конец диапазона, заданные при вызове (для контроля выполнения программы).

*/

// Функция для поиска простых чисел методом перебора
void findPrimesByTrialDivision(int start, int end) {
    auto start_time = std::chrono::steady_clock::now();
    std::vector<int> primes;
    for (int i = start; i <= end; ++i) {
        if (isPrime(i)) {
            primes.push_back(i);
        }
    }
    auto end_time = std::chrono::steady_clock::now();
    std::cout << "Trial Division: Found " << primes.size() << " prime numbers in "
              << std::chrono::duration_cast<std::chrono::milliseconds>(end_time - start_time).count()
              << " milliseconds" << std::endl;
}

// Функция для поиска простых чисел методом Решета Эратосфена
void findPrimesBySieveOfEratosthenes(int start, int end) {
    auto start_time = std::chrono::steady_clock::now();
    std::vector<bool> isPrime(end + 1, true);
    isPrime[0] = isPrime[1] = false;
    for (int p = 2; p * p <= end; ++p) {
        if (isPrime[p]) {
            for (int i = p * p; i <= end; i += p) {
                isPrime[i] = false;
            }
        }
    }
    std::vector<int> primes;
    for (int i = start; i <= end; ++i) {
        if (isPrime[i]) {
            primes.push_back(i);
        }
    }
    auto end_time = std::chrono::steady_clock::now();
    std::cout << "Sieve of Eratosthenes: Found " << primes.size() << " prime numbers in "
              << std::chrono::duration_cast<std::chrono::milliseconds>(end_time - start_time).count()
              << " milliseconds" << std::endl;
}

// Функция для поиска простых чисел методом Ферма
void findPrimesByFermatMethod(int start, int end) {
    auto start_time = std::chrono::steady_clock::now();

    std::vector<int> primes;
    for (int i = start; i <= end; ++i) {
        bool isPrime = true;
        if (i <= 1) {
            isPrime = false;
        } else {
            for (int j = 2; j <= sqrt(i); ++j) {
                if (i % j == 0) {
                    isPrime = false;
                    break;
                }
            }
        }
        if (isPrime) {
            primes.push_back(i);
        }
    }
    auto end_time = std::chrono::steady_clock::now();
    std::cout << "Fermat's Algorithm: Found " << primes.size() << " prime numbers in "
              << std::chrono::duration_cast<std::chrono::milliseconds>(end_time - start_time).count()
              << " milliseconds" << std::endl;
}

int main(int argc, char *argv[]) {
    if (argc < 2 || argc > 3) {
        std::cerr << "Usage: " << argv[0] << " <end_number> [start_number=1]" << std::endl;
        return 1;
    }

    int start = 1; // Начало диапазона по умолчанию
    int end = std::stoi(argv[1]); // Преобразование первого аргумента в конец диапазона

    if (argc == 3) {
        start = std::stoi(argv[2]); // Преобразование второго аргумента в начало диапазона
    }

    if (start > end) {
        int temp = start;
        start = end;
        end = temp;
    }

    if (start < 1 || end < 1) {
        std::cerr << "Error: Numbers must be positive integers." << std::endl;
        return 1;
    }

    std::cout << "Start from: " << start << std::endl; // Добавленная строка "Start from"
    std::cout << "Ends with: " << end << std::endl; // Добавленная строка "Ends with"

    findPrimesByTrialDivision(start, end); // Поиск простых чисел методом перебора
    findPrimesBySieveOfEratosthenes(start, end); // Поиск простых чисел методом Решета Эратосфена
    findPrimesByFermatMethod(start, end); // Поиск простых чисел методом Ферма

    return 0;
}
